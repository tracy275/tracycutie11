<html><head><base href="/"><title>Christmas Tetris</title><style>:root { --block-size: 25px;  } body { background: #1a472a; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: 'Arial', sans-serif; color: #fff; overflow: hidden; position: fixed; width: 100%; height: 100%; background-image: radial-gradient(circle at 50% 50%, transparent 90%, #0a2315 100%), url('data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10' cy='10' r='1' fill='white' opacity='0.3'/%3E%3C/svg%3E'); } .game-title { position: fixed; top: 40px; left: 50%; transform: translateX(-50%); color: #c41e3a; font-size: 32px; text-shadow: 0 0 10px rgba(255,255,255,0.3); font-weight: bold; z-index: 98; } .game-container { position: relative; padding: 15px; background: #234d32; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.3); scale: 0.75; margin-top: 60px; } .controls { position: absolute; right: -180px; top: 20px; transform: none; bottom: auto; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; width: 140px; background: #234d32; padding: 15px; border-radius: 10px; border: 2px solid #c41e3a; box-shadow: 0 0 10px rgba(0,0,0,0.2); } .control-btn { background: #c41e3a; border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s; font-size: 18px; width: 100%; height: 40px; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); } .control-btn:hover { background: #e52844; transform: scale(1.1); } .control-btn:active { transform: scale(0.95); } .game-board { border: 4px solid #c41e3a; background: rgba(0,0,0,0.8); } .grid { display: grid; grid-template-columns: repeat(10, var(--block-size)); grid-template-rows: repeat(20, var(--block-size)); gap: 0.5px; } .cell { width: var(--block-size); height: var(--block-size); border: 0.5px solid rgba(255,255,255,0.1); } .piece-previews { position: absolute; left: -120px; top: 20px; display: flex; flex-direction: column; gap: 20px; } .next-piece, .hold-piece { background: #1a472a; padding: 15px; border-radius: 8px; text-align: center; border: 2px solid #c41e3a; } .preview-grid { display: grid; grid-template-columns: repeat(4, 20px); grid-template-rows: repeat(4, 20px); gap: 1px; background: rgba(0,0,0,0.8); padding: 5px; margin: 10px auto; } .preview-cell { width: 20px; height: 20px; border: 0.5px solid rgba(255,255,255,0.1); } .filled { background: #c41e3a; box-shadow: inset 0 0 8px rgba(255,255,255,0.5); border-radius: 4px; } .active { background: #45b545; box-shadow: inset 0 0 8px rgba(255,255,255,0.5); border-radius: 4px; } .snowflake { position: fixed; color: white; font-size: 20px; animation: fall linear forwards; } @keyframes fall { to { transform: translateY(100vh); } } .countdown { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; color: #c41e3a; text-shadow: 0 0 20px rgba(255,255,255,0.5); z-index: 100; font-weight: bold; opacity: 0; transition: opacity 0.3s; } .countdown.visible { opacity: 1; } .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 99; opacity: 0; transition: opacity 0.3s; pointer-events: none; } .overlay.visible { opacity: 1; } .scoreboard { position: absolute; top: auto; left: auto; right: -180px; bottom: 20px; transform: none; z-index: 98; background: #234d32; padding: 15px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.3); border: 2px solid #c41e3a; display: flex; flex-direction: column; gap: 10px; width: 140px; } .score-item { text-align: center; padding: 5px 0; } .score-label { font-size: 12px; color: #45b545; margin-bottom: 3px; } .score-value { font-size: 18px; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.3); } .high-score { color: #ffd700; } .start-menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #234d32; padding: 30px; border-radius: 15px; text-align: center; border: 4px solid #c41e3a; z-index: 100; } .start-menu button { color: white; } .start-btn { background: #c41e3a; color: white; border: none; padding: 8px 25px; font-size: 14px; border-radius: 6px; cursor: pointer; transition: all 0.2s; } .start-btn:hover { background: #e52844; transform: scale(1.05); } .hidden { display: none; } .pause-menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #234d32; padding: 30px; border-radius: 15px; text-align: center; border: 4px solid #c41e3a; z-index: 100; display: none; } .pause-menu.visible { display: block; } .pause-menu h2 { color: #c41e3a; margin-bottom: 20px; } .resume-btn { background: #c41e3a; color: white; border: none; padding: 15px 40px; font-size: 20px; border-radius: 8px; cursor: pointer; transition: all 0.2s; } .resume-btn:hover { background: #e52844; transform: scale(1.05); } .pause-btn { background: #c41e3a; color: white; border: none; padding: 15px 30px; font-size: 20px; border-radius: 8px; cursor: pointer; transition: all 0.2s; width: 100%; } .pause-btn:hover { background: #e52844; transform: scale(1.05); }</style></head><body><div class="overlay" id="overlay"></div><div class="countdown" id="countdown"></div><div class="game-title">Christmas Tetris</div><div class="start-menu" id="start-menu"><button class="start-btn" id="start-btn">Start Game</button></div><div class="game-container"><div class="game-board"><div class="grid" id="grid"></div></div><div class="piece-previews"><div class="next-piece"><h3>Next</h3><div class="preview-grid" id="next-preview"></div></div><div class="hold-piece"><h3>Hold</h3><div class="preview-grid" id="hold-preview"></div></div></div><div class="controls"><button class="control-btn rotate">↻</button><button class="control-btn left">←</button><button class="control-btn down">↓</button><button class="control-btn right">→</button><button class="control-btn drop">⟱</button><button class="control-btn hold">H</button><button class="control-btn pause" id="pause-btn">⏸</button></div><div class="scoreboard"><div class="score-item"><div class="score-label">SCORE</div><div class="score-value" id="score-display">0</div></div><div class="score-item"><div class="score-label">HIGH SCORE</div><div class="score-value high-score" id="highscore-display">0</div></div><div class="score-item"><div class="score-label">LEVEL</div><div class="score-value" id="level-display">1</div></div><div class="score-item"><div class="score-label">LINES</div><div class="score-value" id="lines-display">0</div></div></div></div><div class="pause-menu" id="pause-menu"><h2>Game Paused</h2><button class="resume-btn" id="resume-btn">Resume</button></div><script>const GRID_WIDTH = 10; const GRID_HEIGHT = 20; let grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0)); let score = 0; let highScore = localStorage.getItem('tetrisHighScore') || 0; let level = 1; let totalLines = 0; let currentPiece = null; let currentPosition = { x: 0, y: 0 }; let gameInterval; let isGameOver = false; let isPaused = false; let nextPiece = null; let holdPiece = null; let canHold = true; const PIECES = [ [ [0,1,0],[1,1,1],[0,1,0] ], [ [0,1,0],[1,1,1],[0,1,0] ], [ [1,1],[1,1] ], [ [1,1,1,1] ] ]; function createGrid() { const gridElement = document.getElementById('grid'); for (let y = 0; y < GRID_HEIGHT; y++) { for (let x = 0; x < GRID_WIDTH; x++) { const cell = document.createElement('div'); cell.className = 'cell'; cell.setAttribute('data-x', x); cell.setAttribute('data-y', y); gridElement.appendChild(cell); } } } function createPreviewGrids() { const nextPreview = document.getElementById('next-preview'); const holdPreview = document.getElementById('hold-preview'); for (let i = 0; i < 16; i++) { const nextCell = document.createElement('div'); nextCell.className = 'preview-cell'; nextPreview.appendChild(nextCell); const holdCell = document.createElement('div'); holdCell.className = 'preview-cell'; holdPreview.appendChild(holdCell); } } function updatePreviewGrids() { const nextPreviewCells = document.querySelectorAll('#next-preview .preview-cell'); nextPreviewCells.forEach(cell => cell.classList.remove('filled')); if (nextPiece) { const offsetX = Math.floor((4 - nextPiece[0].length) / 2); const offsetY = Math.floor((4 - nextPiece.length) / 2); for (let y = 0; y < nextPiece.length; y++) { for (let x = 0; x < nextPiece[y].length; x++) { if (nextPiece[y][x]) { const index = (y + offsetY) * 4 + (x + offsetX); if (nextPreviewCells[index]) { nextPreviewCells[index].classList.add('filled'); } } } } } const holdPreviewCells = document.querySelectorAll('#hold-preview .preview-cell'); holdPreviewCells.forEach(cell => cell.classList.remove('filled')); if (holdPiece) { const offsetX = Math.floor((4 - holdPiece[0].length) / 2); const offsetY = Math.floor((4 - holdPiece.length) / 2); for (let y = 0; y < holdPiece.length; y++) { for (let x = 0; x < holdPiece[y].length; x++) { if (holdPiece[y][x]) { const index = (y + offsetY) * 4 + (x + offsetX); if (holdPreviewCells[index]) { holdPreviewCells[index].classList.add('filled'); } } } } } } function updateGrid() { const cells = document.querySelectorAll('.cell'); cells.forEach(cell => { const x = parseInt(cell.getAttribute('data-x')); const y = parseInt(cell.getAttribute('data-y')); cell.className = 'cell'; if (grid[y][x]) { cell.classList.add('filled'); } if (currentPiece && isPartOfCurrentPiece(x, y)) { cell.classList.add('active'); } }); } function isPartOfCurrentPiece(x, y) { if (!currentPiece) return false; const pieceHeight = currentPiece.length; const pieceWidth = currentPiece[0].length; for (let py = 0; py < pieceHeight; py++) { for (let px = 0; px < pieceWidth; px++) { if (currentPiece[py][px] && currentPosition.x + px === x && currentPosition.y + py === y) { return true; } } } return false; } function spawnPiece() { if (!nextPiece) { nextPiece = PIECES[Math.floor(Math.random() * PIECES.length)]; } currentPiece = nextPiece; nextPiece = PIECES[Math.floor(Math.random() * PIECES.length)]; currentPosition = { x: Math.floor(GRID_WIDTH / 2) - Math.floor(currentPiece[0].length / 2), y: 0 }; if (!canMove(currentPosition.x, currentPosition.y)) { gameOver(); } updatePreviewGrids(); } function canMove(newX, newY) { for (let y = 0; y < currentPiece.length; y++) { for (let x = 0; x < currentPiece[y].length; x++) { if (currentPiece[y][x]) { const nextX = newX + x; const nextY = newY + y; if (nextX < 0 || nextX >= GRID_WIDTH || nextY >= GRID_HEIGHT || (nextY >= 0 && grid[nextY][nextX])) { return false; } } } } return true; } function movePiece(dx, dy) { if (canMove(currentPosition.x + dx, currentPosition.y + dy)) { currentPosition.x += dx; currentPosition.y += dy; updateGrid(); return true; } return false; } function rotatePiece() { const rotated = currentPiece[0].map((_, i) => currentPiece.map(row => row[i]).reverse()); const originalPiece = currentPiece; currentPiece = rotated; if (!canMove(currentPosition.x, currentPosition.y)) { currentPiece = originalPiece; return false; } updateGrid(); return true; } function lockPiece() { for (let y = 0; y < currentPiece.length; y++) { for (let x = 0; x < currentPiece[y].length; x++) { if (currentPiece[y][x]) { const gridY = currentPosition.y + y; if (gridY >= 0) { grid[gridY][currentPosition.x + x] = 1; } } } } clearLines(); spawnPiece(); canHold = true; } function clearLines() { let linesCleared = 0; for (let y = GRID_HEIGHT - 1; y >= 0; y--) { if (grid[y].every(cell => cell === 1)) { grid.splice(y, 1); grid.unshift(Array(GRID_WIDTH).fill(0)); linesCleared++; y++; } } if (linesCleared > 0) { totalLines += linesCleared; score += linesCleared * 100 * level; level = Math.floor(totalLines / 10) + 1; if (score > highScore) { highScore = score; localStorage.setItem('tetrisHighScore', highScore); } updateScoreboard(); updateGameSpeed(); } } function updateScoreboard() { document.getElementById('score-display').textContent = score; document.getElementById('highscore-display').textContent = highScore; document.getElementById('level-display').textContent = level; document.getElementById('lines-display').textContent = totalLines; } function updateGameSpeed() { clearInterval(gameInterval); gameInterval = setInterval(gameLoop, Math.max(100, 1000 - (level * 50))); } function gameLoop() { if (!isPaused) { if (!movePiece(0, 1)) { lockPiece(); } } } function createSnowflake() { const snowflake = document.createElement('div'); snowflake.className = 'snowflake'; snowflake.textContent = '❄'; snowflake.style.left = Math.random() * window.innerWidth + 'px'; snowflake.style.animationDuration = Math.random() * 3 + 2 + 's'; document.body.appendChild(snowflake); snowflake.addEventListener('animationend', () => { snowflake.remove(); }); } function gameOver() { isGameOver = true; clearInterval(gameInterval); if (score > highScore) { highScore = score; localStorage.setItem('tetrisHighScore', highScore); } setTimeout(() => { alert(`Game Over! Score: ${score}`); document.getElementById('start-menu').classList.remove('hidden'); }, 500); } function togglePause() { if (isGameOver) return; isPaused = !isPaused; const pauseMenu = document.getElementById('pause-menu'); const overlay = document.getElementById('overlay'); const pauseBtn = document.getElementById('pause-btn'); if (isPaused) { clearInterval(gameInterval); pauseMenu.classList.add('visible'); overlay.classList.add('visible'); pauseBtn.textContent = '▶'; } else { updateGameSpeed(); pauseMenu.classList.remove('visible'); overlay.classList.remove('visible'); pauseBtn.textContent = '⏸'; } } function holdCurrentPiece() { if (!canHold) return; if (!holdPiece) { holdPiece = currentPiece; spawnPiece(); } else { const temp = currentPiece; currentPiece = holdPiece; holdPiece = temp; currentPosition = { x: Math.floor(GRID_WIDTH / 2) - Math.floor(currentPiece[0].length / 2), y: 0 }; } canHold = false; updatePreviewGrids(); updateGrid(); } function startGame() { const startMenu = document.getElementById('start-menu'); const overlay = document.getElementById('overlay'); const countdownEl = document.getElementById('countdown'); grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0)); score = 0; level = 1; totalLines = 0; currentPiece = null; isGameOver = false; isPaused = false; nextPiece = null; holdPiece = null; canHold = true; startMenu.classList.add('hidden'); document.getElementById('pause-menu').classList.remove('visible'); overlay.classList.add('visible'); countdownEl.classList.add('visible'); let count = 3; countdownEl.textContent = count; const countdownInterval = setInterval(() => { count--; if (count > 0) { countdownEl.textContent = count; } else if (count === 0) { countdownEl.textContent = 'GO!'; } else { clearInterval(countdownInterval); overlay.classList.remove('visible'); countdownEl.classList.remove('visible'); createGrid(); createPreviewGrids(); spawnPiece(); updateGameSpeed(); updateScoreboard(); } }, 1000); } document.getElementById('start-btn').addEventListener('click', startGame); document.getElementById('resume-btn').addEventListener('click', () => { if (isPaused) togglePause(); }); const pauseBtn = document.getElementById('pause-btn'); pauseBtn.addEventListener('click', () => { if (!isGameOver) togglePause(); }); pauseBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isGameOver) togglePause(); }); document.querySelector('.left').addEventListener('click', () => { if (!isGameOver) movePiece(-1, 0); }); document.querySelector('.right').addEventListener('click', () => { if (!isGameOver) movePiece(1, 0); }); document.querySelector('.down').addEventListener('click', () => { if (!isGameOver) movePiece(0, 1); }); document.querySelector('.rotate').addEventListener('click', () => { if (!isGameOver) rotatePiece(); }); document.querySelector('.drop').addEventListener('click', () => { if (!isGameOver) { while(movePiece(0, 1)) {} } }); document.querySelector('.hold').addEventListener('click', () => { if (!isGameOver && !isPaused) holdCurrentPiece(); }); setInterval(createSnowflake, 200); updateScoreboard(); document.getElementById('start-menu').classList.remove('hidden');</script></body></html>